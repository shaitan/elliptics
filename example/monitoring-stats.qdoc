\page monitoring-stats.html Monitor statistics
\brief Description of all statistics available from monitor

\tableofcontent

\section introduction Introduction

Elliptics can collect and provides access to statistics. This statistics includes current state of system
where dnet_ioserv is run, parameters and states of Elliptics internal subsystems and some measurements
of Elliptics performance. Elliptics provides access to this statistics via HTTP or via C++ or Python bindings.

\section monitor_system Monitor subsystem

Elliptics monitor subsystem consists of handystats, set of statistics providers and simple HTTP server based on boost::asio.
About handystats you can read at handystats help page: http://handystats.readthedocs.org/en/latest/,
statistics that are collected by handystats you can read at Handystats statistics section. Each statistics provider
collects statistics about some Elliptics subsystem or feature, also some provider is made for collecting some special
sort of information. Simple HTTP server provides HTTP API to access statistics. It's described at HTTP Monitor API section.

\section configuration Configuration

Elliptics monitor can be configurated via common dnet_ioserv config. It has special value: "monitor" which has follow schema:
`{
	"port": {
		"description": "port that will be listened for HTTP requests",
		"type": "integer" }
}`
Handystats has independent value: "handystats_config" that sets path to handystats config file.
Optionally "monitor" section may contain "top" section - it enables computation of top keys statistics by elliptics process.
If section "top" is empty, then statistics of top keys always contains empty list of keys. "top" section has follow schema:
`{
	"top_length": "maximum number of top keys returned by provider of top statistics",
	"events_size": "amount of memory in bytes, available for storing events data",
	"period_in_seconds": "only events within time window of 'period_in_seconds' seconds are considered in top keys statistics"
}`

\section http_API HTTP Monitor API

Monitor HTTP server supports follow URI:
- http://host:monitor_port/list			- Retrieves a list of acceptable statistics
- http://host:monitor_port/all			- Retrieves all statistics from all submodules
- http://host:monitor_port/cache		- Retrieves statistics about cache
- http://host:monitor_port/io			- Retrieves statistics about io statistics
- http://host:monitor_port/commands		- Retrieves statistics about commands
- http://host:monitor_port/backend		- Retrieves statistics about backend
- http://host:monitor_port/stats		- Retrieves in-process runtime statistics
- http://host:monitor_port/procfs		- Retrieves system statistics about process
- http://host:monitor_port/top			- Retrieves statistics of top keys ordered by generated traffic
- http://host:monitor_port/?categories=cats	- Retrieves statistics of categories combination @cats

\section categories Monitor categories

Monitor devides all statistics by categories. It allows client to request some part of statistics (combination of categories)
if it is needed. Monitor provides follow categories:
- backend - statistics of all backends
- cache - cache statistics
- io - statistics about input/output performance
- commands - statistics of processed commands
- stats - statistics provided by handystats
- procfs - system statistics of elliptics process
- top - statistics of top keys ordered by generated traffic
- all - all available statistics

\section base_json Monitor json base schema:

Statistics json for all combination of categories has common schema:

`{
	"timestamp": {
		"description": "timestamp of the json",
		"type": "object",
		"tv_sec": {
			"description": "seconds part of timestamp",
			"type": "integer" },
		"tv_usec": {
			"description": "microseconds part of timestamp",
			"type": "integer" } },
	"string_timestamp": {
		"description": "string representation of previous timestamp",
		"type": "string" },
	"monitor_status": {
		"description": "status of monitor system",
		"type": { "enum": ["enabled", "disabled"] }
	}
}`

After "monitor_status" there are per catergory fileds except cache.

\section backend_statistics Backends statistics

This category provides statistics of all initialized backends statistics:

` "backends": {
	"description": "collection of per backend statistics",
	"type": "object",
	"<backend_id>": {
		"description": "statistics of one backend with <backend_id>",
		"type": "object",
		"backend_id": {
			"description": "identifier of the backend",
			"type": "number" },
		"status": {
			"description": "status of the backend",
			"type": "object",
			"state": {
				"description": "state of the backend. 0 - disabled, 1- enabled, 2 - activating, 3 - deactivating",
				"type": { "enum": [ 0, 1, 2, 3] } },
			"string_state": {
				"description": "human-readable state of the backend",
				"type": { "enum": ["enable", "disable", "activating", "deactivating"] } },
			"defrag_state": {
				"description": "state of the backend defragmentation process. 0 - not-started, 1 - in-progress",
				"type": { "enum": [ 0, 1 ] } },
			"string_defrag_state": {
				"description": "human-readable state of the backend defragmentation process",
				"type": { "enum": [ "in-progress", "not-started" ] } },
			"last_start": {
				"description": "timestamp of the last defragmentation start",
				"type": "object",
				"tv_sec": {
					"description": "seconds part of timestamp",
					"type": "number" },
				"tv_usec": {
					"description": "microseconds part of timestamp",
					"type": "number" } },
			"string_last_time": {
				"description": "human-readable timestamp of the last defragmentation start",
				"type": "string" },
			"last_start_err": {
				"description": "error code of the last defragmentation",
				"type": "number" },
			"read_only": {
				"description": "is the backend in read-only mode",
				"type": "boolen" },
			"delay": {
				"description": "time which will backend sleep before start to handling command",
				"type": "number" } } }
	... }`

\section cache_category Cache statistics

Each backend at Elliptics node has own independent cache. That is why each cache statistics is placed at backend level.
Cache json has follow schema:

` "backends": {
	"description": "collection of per backend statistics",
	"type": "object",
	"<backend_id>": {
		"description": "statistics of one backend with <backend_id>",
		"type": "object",
		"backend_id": {
			"description": "identifier of the backend",
			"type": "number" },
		"status": {
			"description": "status of the backend. Described at Backends statistics section",
			"type": "object" },
		"cache": {
			"description": "statistics of the backend cache",
			"type": "object",
			"total_cache": {
				"description": "aggregated statistics of all caches of the backend",
				"type": "object",
				"size_stats": {
					"description": "size statistics of all caches of the backend",
					"type": "object",
					"size": {
						"description": "total size of all caches of the backend",
						"type": "number" },
					"removing_size": {
						"description": "total size of all removing object from all caches of the backend",
						"type": "number" },
					"objects": {
						"description": "total number of object in all caches of the backend",
						"type": "number" },
					"removing_objects": {
						"description": "total number of all removing object from all caches of the backend",
						"type": "number" },
					"pages_sizes": {
						"description": "aggregated by pages size of all caches of the backend",
						"type": "array",
						"minItems": 1,
						"items": { "type": "number" } },
					"pages_max_sizes": {
						"description": "max size of aggregated by pages all caches of the backend",
						"type": "array",
						"minItems": 1,
						"items": { "type": "number" } } } }
			"caches": {
				"description": "collection of per cache statistics",
				"type": "object",
				"<cache_id>": {
					"description": "statistics of one cache with <cache_id>",
					"type": "object",
					"size": {
						"description": "total size of the cache",
						"type": "number" },
					"removing_size": {
						"description": "total size of all removing object from the cache",
						"type": "number" },
					"objects": {
						"description": "total number of object in the cache",
						"type": "number" },
					"removing_objects": {
						"description": "total number of removing object from the cache",
						"type": "number" },
					"pages_sizes": {
						"description": "size of each cache page of the cache",
						"type": "array",
						"minItems": 1,
						"items": { "type": "number" } },
					"pages_max_sizes": {
						"description": "max size of each page of the cache",
						"type": "array",
						"minItems": 1,
						"items": { "type": "number" } } } }
		... } } }`

\section io_category IO statistics

This category provides input/output queues between io pools and net pool and includes connections statistics.
The json has follow schema:

`{
	"io": {
		"description": "statistics of system (node) I/O queues and connections statistics",
		"type": "object",
		"blocking": {
			"description": "statistics of system blocking io pool queue",
			"type": "object",
			"current_size": {
				"description": "number of requests in the queue",
				"type": "number" } },
		"nonblocking": {
			"description": "statistics of system nonblocking io pool queue",
			"type": "object",
			"current_size": {
				"description": "number of requests in the queue",
				"type": "number" } },
		"output": {
			"description": "statistics system output queue",
			"type": "object",
			"current_size": {
				"description": "number of requests in the queue",
				"type": "number" } },
		"states": {
			"description": "statistics of each alive client connections to the node",
			"type": "object",
			"<ip>:<port>": {
				"description": "statistics of one alive client connection",
				"type": "object",
				"send_queue_size": {
					"description": "number of requests in send queue for the connection",
					"type": "number" },
				"la": {
					"description": "loadavg of the connection",
					"type": "number" },
				"free": {
					"description": "loadavg of the connection",
					"type": "number" },
				"weight": {
					"description": "weight of the connection based on connection response history",
					"type": "double" },
				"stall": {
					"description": "number of timeouted in line requests",
					"type": "number" },
				"join_state": {
					"description": "join state: 0 - client, 1 - server",
					"type": { "enum": [ 0, 1 ] } } },
			... },
			"blocked": {
				"description": "shows that queue is blocked because of overload",
				"type": "boolean" },
		"backends": {
			"description": "collection of per backend io queues statistics",
			"type": "object",
			"<backend_id>": {
				"io": {
					"description": "statistics of the backend io queues",
					"type": "object",
					"blocking": {
						"description": "statistics of the backend blocking io pool queue",
						"type": "object",
						"current_size": {
							"description": "number of requests in the queue",
							"type": "number" } },
					"nonblocking": {
						"description": "statistics of the backend nonblocking io pool queue",
						"type": "object",
						"current_size": {
							"description": "number of requests in the queue",
							"type": "number" } } } },
			...  }, } }`

\section commands_category Commands statistics

Statistics of all handled commands. The json has follow schema:

`"commands": {
	"<command>": {
		"description": "statistics of all handled <command> requests. If no <command> requests has been handled - this object will be missed",
		"type": "object",
		"cache": {
			"description": "statistics of handled in cache <command> requests",
			"type": "object",
			"outside": {
				"description": "statistics of <command> requests sended by client",
				"type": "object",
				"successes": {
					"description": "number of succeded handles",
					"type": "number" }
				"failures": {
					"description": "number of failed handles",
					"type": "number" }
				"size": {
					"description": "summarized size of datas participated in requests",
					"type": "number" }
				"time": {
					"description": "summarized time in usec of all handles",
					"type": "number" } },
			"internal": {
				"description": "statistics of <command> requests sended by node itself",
				"type": "object",
				"successes": {
					"description": "number of succeded handles",
					"type": "number" }
				"failures": {
					"description": "number of failed handles",
					"type": "number" }
				"size": {
					"description": "summarized size of datas participated in requests",
					"type": "number" }
				"time": {
					"description": "summarized time in usec of all handles",
					"type": "number" } } },
		"disk": {
			"description": "statistics of handled in disk (backend) <command> requests",
			"type": "object",
			"outside": {
				"description": "statistics of <command> requests sended by client",
				"type": "object",
				"successes": {
					"description": "number of succeded handles",
					"type": "number" }
				"failures": {
					"description": "number of failed handles",
					"type": "number" }
				"size": {
					"description": "summarized size of datas participated in requests",
					"type": "number" }
				"time": {
					"description": "summarized time in usec of all handles",
					"type": "number" } },
			"internal": {
				"description": "statistics of <command> requests sended by node itself",
				"type": "object",
				"successes": {
					"description": "number of succeded handles",
					"type": "number" }
				"failures": {
					"description": "number of failed handles",
					"type": "number" }
				"size": {
					"description": "summarized size of datas participated in requests",
					"type": "number" }
				"time": {
					"description": "summarized time in usec of all handles",
					"type": "number" } } },
		"total": {
			"description": "statistics of all handled <command> requests",
			"type": "object",
			"storage": {
				"description": "statistics of handled <command> requests sended by another server",
				"type": "object",
				"successes": {
					"description": "number of succeded handles",
					"type": "number" },
				"failures": {
					"description": "number of failed handles",
					"type": "number" } },
			"proxy": {
				"description": "statistics of handled <command> requests sended by client",
				"type": "object",
				"successes": {
					"description": "number of succeded handles",
					"type": "number" },
				"failures": {
					"description": "number of failed handles",
					"type": "number" } } }
	... } }`

\section handystats_statistics Handystats statistics

Elliptics collects some statistics by Handystats. This statistics can be requested by:
- DNET_MONITOR_STATS in C++ binging
- elliptics.monitor_stat_categories.stats in Python binging
- http://`host`:`monitor_port`/stats

Handystats collects follow statistics:
- io.cmd - time of commands, overall for entire command stream of the node
- io.cmd.{<any elliptics command type in upper case>} - time of commands for each type
- io.cmd.{<any elliptics command type in upper case>}.lock_time - time spent in id lock waiting, for each command type,
	(this will be 0 for commands with DNET_FLAGS_NOLOCK flag set)
- io.cmd_recursive - time of commands that originate from other commands execution, overall for entire elliptics command stream
	(right now only BULK_READ generate subcommands like that)
- io.cmd_recursive.READ - time of READs that originate from BULK_READ commands
- cache.{READ,WRITE,DEL} - time spent in cache layer, for listed command types
- eblob_backend.cmd.{READ,WRITE,LOOKUP,DEL,READ_RANGE,DEL_RANGE} - time spent in eblob backend layer, for listed command types
- io.notify.update - time of sending notification to registered target
- io.notify.{add,remove} - time of adding or removing notification target
- io.cmds - tracks all input commands that processed by this node
	("rate" is the most suitable statistic for this, same goes for io.forwards and io.replies)
- io.forwards - tracks all input commands that forwarded to other node
- io.replies - tracks all input commands that are really replies (has DNET_FLAGS_REPLY flag set)
- io.input.queue.size - tracks size of virtual input queue of the node
	("rate" or "interval-sum" statistics are suitable to assess command stream rate, same goes for io.output.queue.size)
- io.output.queue.size - tracks instant size of output queue of the node
- pool.{sys,<backend id>}.{blocking,nonblocking}.queue.size - tracks size of a pool's input queue
	("rate" or "interval-sum" statistics are suitable to assess command stream rate)
- pool.{sys,<backend id>}.{blocking,nonblocking}.queue.wait_time - time commands spent waiting in a pool's input queue
- pool.{sys,<backend id>}.{blocking,nonblocking}.active_threads - tracks pool's thread utilization (how many threads are actually working)


\section procfs_statistics Procfs statistics

Statistics obtained from procfs, sysfs, devfs etc. The json has follow schema:

`"procfs": {
	"description": "statistics obtained from procfs, sysfs etc.",
	"type": "object",
	"vm": {
		"description": "virtual memory statistics",
		"type": "object",
		"error": {
			"description": "error code of vm statistics obtaining.",
			"type": "number" },
		"string_error": {
			"description": "string representation of the previous error. If all is ok it is empty",
			"type": "string" },
		"la": {
			"description": "loadavg statistics",
			"type": "array",
			"items": { "type": "number" } },
		"total": {
			"description": "total amount of physical RAM, in kilobytes",
			"type": "number" },
		"active": {
			"description": "the total amount of buffer or pacge cache memory, in kilobytes, that is in active use",
			"type": "number" },
		"inactive": {
			"description": "the total amount of buffer or pacge cache memory, in kilobytes, that are free and available",
			"type": "number" },
		"free": {
			"description": "the amount of physical RAM, in kilobytes, left unused by the system",
			"type": "number" },
		"cached": {
			"description": "the amount of physical RAM, in kilobytes, used as cache memory",
			"type": "number" },
		"buffers": {
			"description": "the amount of physical RAM, in kilobytes, used for file buffers",
			"type": "number" } },
	"io": {
		"description": "I/O statistics. More detailes about these statistics could be found at http://man7.org/linux/man-pages/man5/proc.5.html at '/proc/[pid]/io' section",
		"type": "object",
		"error": {
			"description": "error code of I/O statistics obtaining.",
			"type": "number" },
		"string_error": {
			"description": "string representation of the previous error. If all is ok it is empty",
			"type": "string" },
		"rchar": {
			"description": "characters read, the number of bytes which the server has caused to be read from disk.",
			"type": "number" },
		"wchar": {
			"description": "characters written, the number of bytes which the server has caused or shall cause to be written to disk",
			"type": "number" },
		"syscr": {
			"description": "read syscalls, attempt to count the number of read I/O operations—that is, system calls such as read(2) and pread(2)",
			"type": "number" },
		"syscw": {
			"description": "write syscalls, attempt to count the number of write I/O operations that is, system calls such as write(2) and pwrite(2)",
			"type": "number" },
		"read_bytes": {
			"description": "bytes read, attempt to count the number of bytes which this process really did cause to be fetched from the storage layer",
			"type": "number" },
		"write_bytes": {
			"description": "bytes written, attempt to count the number of bytes which this process caused to be sent to the storage layer",
			"type": "number" },
		"cancelled_write_bytes": {
			"description": "represents the number of bytes which this process caused to not happen, by truncating pagecache",
			"type": "number" } },
	"stat": {
		"description": "status information about the server process. More detailes about these statistics could be found at http://man7.org/linux/man-pages/man5/proc.5.html at '/proc/[pid]/stat' and '/proc/[pid]/statm' sections ",
		"type": "object",
		"error": {
			"description": "error code of I/O statistics obtaining.",
			"type": "number" },
		"string_error": {
			"description": "string representation of the previous error. If all is ok it is empty",
			"type": "string" },
		"threads_num": {
			"description": "Number of threads in the process",
			"type": "number" },
		"rss": {
			"description": "Resident Set Size: number of pages the process has in real memory.  This is just the pages which count toward text, data, or stack space",
			"type": "number" },
		"vsize": {
			"description": "virtual memory size in bytes",
			"type": "number" },
		"rsslim": {
			"description": "urrent soft limit in bytes on the rss of the process",
			"type": "number" },
		"msize": {
			"description": "total program size, in pages",
			"type": "number" },
		"mresident": {
			"description": "resident set size, in pages",
			"type": "number" },
		"mshare": {
			"description": "shared pages (i.e., backed by a file)",
			"type": "number" },
		"mcode": {
			"description": "text (code) pages",
			"type": "number" },
		"mdata": {
			"description": "data + stack pages",
			"type": "number" } }
}`

\section top_statistics Top keys statistics

Statistics of top keys. The json has follow schema:

`"top": {
	"description": "Statistics of top keys",
	"type": "object",
	"top_by_size": {
		"description": "Statistics of top keys ordered by generated traffic",
		"type": "array",
		"items": {
			"type": "object",
			"group": {
				"description": "group id of key",
				"type": "number"
			},
			"id": {
				"description": "key id (sha512 of file name)",
				"type": "string"
			},
			"size": {
				"description": "generated traffic",
				"type": "number"
			},
			"frequency": {
				"description": "events count during period_in_seconds time window",
				"type": "number"
			}
		}
	}
}`
